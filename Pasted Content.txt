ĞÑÑŒ Ğ´ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ğ¸Ğ¹ Ğ¿Ğ¾ÑÑ–Ğ±Ğ½Ğ¸Ğº Ğ´Ğ»Ñ ÑÑ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ Ñ‚Ğ° Ñ€Ğ¾Ğ·Ğ³Ğ¾Ñ€Ñ‚Ğ°Ğ½Ğ½Ñ Ğ²Ğ°ÑˆĞ¾Ğ³Ğ¾ Telegram-Ğ±Ğ¾Ñ‚Ğ° Ğ´Ğ»Ñ Ğ°Ğ½Ğ¾Ğ½Ñ–Ğ¼Ğ½Ğ¸Ñ… Ğ¿Ğ¸Ñ‚Ğ°Ğ½ÑŒ Ğ½Ğ° Google Cloud Run. Ğ¯, MANUS AI, Ğ¿Ñ€Ğ¾Ğ²ĞµĞ´Ñƒ Ğ²Ğ°Ñ Ñ‡ĞµÑ€ĞµĞ· ÑƒÑÑ– ĞµÑ‚Ğ°Ğ¿Ğ¸: Ğ²Ñ–Ğ´ Ğ¿Ñ–Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ¸ ĞºĞ¾Ğ´Ñƒ Ğ´Ğ¾ Ğ¿ÑƒĞ±Ğ»Ñ–ĞºĞ°Ñ†Ñ–Ñ— Ñ‚Ğ° Ñ‚ĞµÑÑ‚ÑƒĞ²Ğ°Ğ½Ğ½Ñ. ĞœĞ¸ Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ°Ñ”Ğ¼Ğ¾ Ğ²Ğ°Ñˆ ĞºĞ¾Ğ´, Ğ°Ğ´Ğ°Ğ¿Ñ‚ÑƒÑ”Ğ¼Ğ¾ Ğ¹Ğ¾Ğ³Ğ¾ Ğ´Ğ»Ñ Ñ€Ğ¾Ğ±Ğ¾Ñ‚Ğ¸ Ğ· Webhook Ğ½Ğ° Google Cloud Run Ñ– Ñ€Ğ¾Ğ·Ğ³Ğ¾Ñ€Ğ½ĞµĞ¼Ğ¾ Ğ¹Ğ¾Ğ³Ğ¾. ĞŸĞ¾Ñ‡Ğ½ĞµĞ¼Ğ¾!

---

## ĞĞ³Ğ»ÑĞ´ Ğ¿Ñ€Ğ¾Ñ”ĞºÑ‚Ñƒ

Ğ’Ğ°Ñˆ Ğ±Ğ¾Ñ‚ Ğ´Ğ¾Ğ·Ğ²Ğ¾Ğ»ÑÑ” ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°Ğ¼ Ğ°Ğ½Ğ¾Ğ½Ñ–Ğ¼Ğ½Ğ¾ Ğ·Ğ°Ğ´Ğ°Ğ²Ğ°Ñ‚Ğ¸ Ğ¿Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ, ÑĞºÑ– Ğ¾Ğ±Ñ€Ğ¾Ğ±Ğ»ÑÑÑ‚ÑŒÑÑ Ğ°Ğ´Ğ¼Ñ–Ğ½Ñ–ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°Ğ¼Ğ¸ Ğ² Ğ¿Ñ€Ğ¸Ğ²Ğ°Ñ‚Ğ½Ñ–Ğ¹ Ğ³Ñ€ÑƒĞ¿Ñ–, Ğ° Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ñ– Ğ¿ÑƒĞ±Ğ»Ñ–ĞºÑƒÑÑ‚ÑŒÑÑ Ğ² Ğ¿ÑƒĞ±Ğ»Ñ–Ñ‡Ğ½Ğ¾Ğ¼Ñƒ ĞºĞ°Ğ½Ğ°Ğ»Ñ–. ĞœĞ¸ Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ°Ñ”Ğ¼Ğ¾ Ğ²Ğ°Ñˆ Ñ‚Ğ¾ĞºĞµĞ½, ĞºĞ°Ğ½Ğ°Ğ» `@christ_qa`, Ğ³Ñ€ÑƒĞ¿Ñƒ Ğ°Ğ´Ğ¼Ñ–Ğ½Ñ–Ğ² `-1002576988593` Ñ‚Ğ° ID Ğ°Ğ´Ğ¼Ñ–Ğ½Ñ–ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ° `404389668`.

---

## ĞŸĞ¾Ğ¿ĞµÑ€ĞµĞ´Ğ½Ñ– Ğ²Ğ¸Ğ¼Ğ¾Ğ³Ğ¸

ĞŸĞµÑ€ĞµĞ´ Ğ¿Ğ¾Ñ‡Ğ°Ñ‚ĞºĞ¾Ğ¼ Ğ¿ĞµÑ€ĞµĞºĞ¾Ğ½Ğ°Ğ¹Ñ‚ĞµÑÑ, Ñ‰Ğ¾ Ñƒ Ğ²Ğ°Ñ Ñ”:

1. **ĞĞºĞºĞ°ÑƒĞ½Ñ‚ Google Cloud**:
   - Ğ—Ğ°Ñ€ĞµÑ”ÑÑ‚Ñ€ÑƒĞ¹Ñ‚ĞµÑÑ Ğ½Ğ° [Google Cloud](https://cloud.google.com/) Ñ– Ğ°ĞºÑ‚Ğ¸Ğ²ÑƒĞ¹Ñ‚Ğµ Ğ±ĞµĞ·ĞºĞ¾ÑˆÑ‚Ğ¾Ğ²Ğ½Ğ¸Ğ¹ ĞºÑ€ĞµĞ´Ğ¸Ñ‚ ($300), ÑĞºÑ‰Ğ¾ Ñ†Ğµ Ğ²Ğ°Ñˆ Ğ¿ĞµÑ€ÑˆĞ¸Ğ¹ Ğ¿Ñ€Ğ¾Ñ”ĞºÑ‚.
2. **Google Cloud SDK**:
   - Ğ’ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ñ–Ñ‚ÑŒ [Google Cloud SDK](https://cloud.google.com/sdk/docs/install).
3. **Git**:
   - Ğ’ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ñ–Ñ‚ÑŒ [Git](https://git-scm.com/downloads).
4. **Python 3.9+**:
   - ĞŸĞµÑ€ĞµĞºĞ¾Ğ½Ğ°Ğ¹Ñ‚ĞµÑÑ, Ñ‰Ğ¾ Ñƒ Ğ²Ğ°Ñ Ğ²ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾ Python 3.9 Ğ°Ğ±Ğ¾ Ğ½Ğ¾Ğ²Ñ–ÑˆÑƒ Ğ²ĞµÑ€ÑÑ–Ñ.
5. **Telegram Bot Token**:
   - Ğ’Ğ°Ñˆ Ñ‚Ğ¾ĞºĞµĞ½: `7540984242:AAHwnXjpUHjmV4bjCeKgTq7YR0_9fVC_OHs`.
6. **ĞšĞ°Ğ½Ğ°Ğ» Ñ– Ğ³Ñ€ÑƒĞ¿Ğ° Ğ² Telegram**:
   - ĞŸÑƒĞ±Ğ»Ñ–Ñ‡Ğ½Ğ¸Ğ¹ ĞºĞ°Ğ½Ğ°Ğ»: `@christ_qa`.
   - ĞŸÑ€Ğ¸Ğ²Ğ°Ñ‚Ğ½Ğ° Ğ³Ñ€ÑƒĞ¿Ğ° Ğ°Ğ´Ğ¼Ñ–Ğ½Ñ–Ğ²: `-1002576988593`.
   - ID Ğ°Ğ´Ğ¼Ñ–Ğ½Ñ–ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°: `404389668`.

---

## ĞšÑ€Ğ¾Ğº 1: ĞŸÑ–Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ° Ğ¿Ñ€Ğ¾Ñ”ĞºÑ‚Ñƒ

### 1.1. Ğ¡Ñ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ Ñ€Ğ¾Ğ±Ğ¾Ñ‡Ğ¾Ñ— Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ñ–Ñ—

Ğ¡Ñ‚Ğ²Ğ¾Ñ€Ñ–Ñ‚ÑŒ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ñ–Ñ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ñ”ĞºÑ‚Ñƒ Ñ‚Ğ° Ğ¿ĞµÑ€ĞµĞ¹Ğ´Ñ–Ñ‚ÑŒ Ñƒ Ğ½ĞµÑ—:

```bash
mkdir telegram-qa-bot
cd telegram-qa-bot
```

### 1.2. Ğ†Ğ½Ñ–Ñ†Ñ–Ğ°Ğ»Ñ–Ğ·Ğ°Ñ†Ñ–Ñ Git

Ğ†Ğ½Ñ–Ñ†Ñ–Ğ°Ğ»Ñ–Ğ·ÑƒĞ¹Ñ‚Ğµ Git-Ñ€ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ñ€Ñ–Ğ¹:

```bash
git init
```

### 1.3. Ğ¡Ñ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ğ¸Ñ… Ñ„Ğ°Ğ¹Ğ»Ñ–Ğ²

#### **bot.py**
ĞÑÑŒ Ğ°Ğ´Ğ°Ğ¿Ñ‚Ğ¾Ğ²Ğ°Ğ½Ğ° Ğ²ĞµÑ€ÑÑ–Ñ Ğ²Ğ°ÑˆĞ¾Ğ³Ğ¾ ĞºĞ¾Ğ´Ñƒ Ğ´Ğ»Ñ Ñ€Ğ¾Ğ±Ğ¾Ñ‚Ğ¸ Ğ· Webhook Ğ½Ğ° Google Cloud Run. Ğ¡ĞºĞ¾Ğ¿Ñ–ÑĞ¹Ñ‚Ğµ Ñ—Ñ— Ğ² Ñ„Ğ°Ğ¹Ğ» `bot.py`:

```python
import os
import logging
import json
from datetime import datetime
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, Filters, ContextTypes, CallbackQueryHandler, ConversationHandler
from dotenv import load_dotenv
from typing import Dict, List
import asyncio
from aiohttp import web

# ĞĞ°Ğ»Ğ°ÑˆÑ‚ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ»Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Ğ—Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ĞµĞ½Ğ½Ñ Ğ·Ğ¼Ñ–Ğ½Ğ½Ğ¸Ñ… Ğ¾Ñ‚Ğ¾Ñ‡ĞµĞ½Ğ½Ñ
load_dotenv()

# ĞšĞ¾Ğ½ÑÑ‚Ğ°Ğ½Ñ‚Ğ¸ Ğ´Ğ»Ñ ConversationHandler
CHOOSING, TYPING_QUESTION, TYPING_CATEGORY, TYPING_REPLY = range(4)

# Ğ—Ğ¼Ñ–Ğ½Ğ½Ñ– Ğ¾Ñ‚Ğ¾Ñ‡ĞµĞ½Ğ½Ñ
TOKEN = os.getenv('TELEGRAM_TOKEN')
CHANNEL_ID = os.getenv('CHANNEL_ID')
ADMIN_GROUP_ID = os.getenv('ADMIN_GROUP_ID')
ADMIN_IDS = [int(id_) for id_ in os.getenv('ADMIN_IDS', '').split(',') if id_]

# ĞšĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ñ–Ñ— Ğ¿Ğ¸Ñ‚Ğ°Ğ½ÑŒ
CATEGORIES: Dict[str, str] = {
    'general': 'ğŸŒŸ Ğ—Ğ°Ğ³Ğ°Ğ»ÑŒĞ½Ñ–',
    'spiritual': 'ğŸ™ Ğ”ÑƒÑ…Ğ¾Ğ²Ğ½Ñ–',
    'personal': 'ğŸ‘¤ ĞÑĞ¾Ğ±Ğ¸ÑÑ‚Ñ–',
    'urgent': 'âš¡ï¸ Ğ¢ĞµÑ€Ğ¼Ñ–Ğ½Ğ¾Ğ²Ñ–'
}

# Ğ†Ğ½Ñ–Ñ†Ñ–Ğ°Ğ»Ñ–Ğ·Ğ°Ñ†Ñ–Ñ Ğ±Ğ¾Ñ‚Ğ°
application = Application.builder().token(TOKEN).build()

class Database:
    def __init__(self, filename='db.json'):
        self.filename = filename
        self.questions = {}
        self.stats = {
            'total_questions': 0,
            'answered_questions': 0,
            'categories': {}
        }
        self.load()

    def load(self):
        try:
            if os.path.exists(self.filename):
                with open(self.filename, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    self.questions = data.get('questions', {})
                    self.stats = data.get('stats', {
                        'total_questions': 0,
                        'answered_questions': 0,
                        'categories': {}
                    })
        except Exception as e:
            logger.error(f"ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ·Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ĞµĞ½Ğ½Ñ– Ğ±Ğ°Ğ·Ğ¸ Ğ´Ğ°Ğ½Ğ¸Ñ…: {e}")

    def save(self):
        try:
            with open(self.filename, 'w', encoding='utf-8') as f:
                json.dump({
                    'questions': self.questions,
                    'stats': self.stats
                }, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ·Ğ±ĞµÑ€ĞµĞ¶ĞµĞ½Ğ½Ñ– Ğ±Ğ°Ğ·Ğ¸ Ğ´Ğ°Ğ½Ğ¸Ñ…: {e}")

    def add_question(self, question_id: str, question_data: dict):
        self.questions[question_id] = question_data
        self.stats['total_questions'] += 1
        category = question_data.get('category')
        if category:
            self.stats['categories'][category] = self.stats['categories'].get(category, 0) + 1
        self.save()

    def update_question(self, question_id: str, update_data: dict):
        if question_id in self.questions:
            self.questions[question_id].update(update_data)
            if update_data.get('status') == 'answered':
                self.stats['answered_questions'] += 1
            self.save()

    def get_question(self, question_id: str) -> dict:
        return self.questions.get(question_id, {})

# Ğ†Ğ½Ñ–Ñ†Ñ–Ğ°Ğ»Ñ–Ğ·Ğ°Ñ†Ñ–Ñ Ğ±Ğ°Ğ·Ğ¸ Ğ´Ğ°Ğ½Ğ¸Ñ…
db = Database()

def get_main_keyboard():
    keyboard = [
        ["ğŸ“ Ğ—Ğ°Ğ´Ğ°Ñ‚Ğ¸ Ğ¿Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ"],
        ["ğŸ“‹ ĞœĞ¾Ñ— Ğ¿Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ", "âœ‰ï¸ ĞœĞ¾Ñ— Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ñ–"],
        ["â“ Ğ”Ğ¾Ğ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°"],
        [f"ğŸ“¢ ĞšĞ°Ğ½Ğ°Ğ» Ğ· Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´ÑĞ¼Ğ¸"]
    ]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

def get_category_keyboard():
    keyboard = []
    for cat_id, name in CATEGORIES.items():
        keyboard.append([InlineKeyboardButton(text=name, callback_data=f"cat_{cat_id}")])
    keyboard.append([InlineKeyboardButton("ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_to_main")])
    return InlineKeyboardMarkup(keyboard)

def get_admin_keyboard(question_id: str):
    keyboard = [
        [
            InlineKeyboardButton("âœ… Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–ÑÑ‚Ğ¸", callback_data=f"answer_{question_id}"),
            InlineKeyboardButton("âŒ Ğ’Ñ–Ğ´Ñ…Ğ¸Ğ»Ğ¸Ñ‚Ğ¸", callback_data=f"reject_{question_id}")
        ],
        [
            InlineKeyboardButton("â­ï¸ Ğ’Ğ°Ğ¶Ğ»Ğ¸Ğ²Ğµ", callback_data=f"important_{question_id}"),
            InlineKeyboardButton("ğŸ“Œ Ğ—Ğ°ĞºÑ€Ñ–Ğ¿Ğ¸Ñ‚Ğ¸", callback_data=f"pin_{question_id}")
        ]
    ]
    return InlineKeyboardMarkup(keyboard)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    logger.info(f"ĞšĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡ {user.id} Ğ·Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ğ² Ğ±Ğ¾Ñ‚Ğ°")
    if update.effective_chat.type == 'private':
        welcome_text = (
            f"ğŸ‘‹ Ğ’Ñ–Ñ‚Ğ°Ñ, {user.first_name}!\n\n"
            "ğŸ¤– Ğ¦Ğµ Ğ±Ğ¾Ñ‚ Ğ´Ğ»Ñ Ğ°Ğ½Ğ¾Ğ½Ñ–Ğ¼Ğ½Ğ¸Ñ… Ğ¿Ğ¸Ñ‚Ğ°Ğ½ÑŒ.\n\n"
            "ğŸ“ Ğ’Ğ¸ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ:\n"
            "â€¢ Ğ—Ğ°Ğ´Ğ°Ğ²Ğ°Ñ‚Ğ¸ Ğ¿Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ Ğ°Ğ½Ğ¾Ğ½Ñ–Ğ¼Ğ½Ğ¾\n"
            "â€¢ ĞŸĞµÑ€ĞµĞ³Ğ»ÑĞ´Ğ°Ñ‚Ğ¸ ÑĞ²Ğ¾Ñ— Ğ¿Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ\n"
            "â€¢ ĞÑ‚Ñ€Ğ¸Ğ¼ÑƒĞ²Ğ°Ñ‚Ğ¸ Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ñ– Ğ² ĞºĞ°Ğ½Ğ°Ğ»Ñ–\n\n"
            "â—ï¸ Ğ’ÑÑ– Ğ¿Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ Ğ¿Ğ¾Ğ²Ğ½Ñ–ÑÑ‚Ñ Ğ°Ğ½Ğ¾Ğ½Ñ–Ğ¼Ğ½Ñ–\n"
            "âœ… Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ñ– Ğ¿ÑƒĞ±Ğ»Ñ–ĞºÑƒÑÑ‚ÑŒÑÑ Ğ² ĞºĞ°Ğ½Ğ°Ğ»Ñ–"
        )
        await update.message.reply_text(welcome_text, reply_markup=get_main_keyboard())
    return CHOOSING

async def webhook(request):
    try:
        update = Update.de_json(await request.json(), application.bot)
        await application.process_update(update)
        return web.Response(status=200)
    except Exception as e:
        logger.error(f"ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ° Ğ² Webhook: {e}")
        return web.Response(status=500)

async def start_server():
    app = web.Application()
    app.router.add_post('/webhook', webhook)
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, '0.0.0.0', 8080)
    await site.start()

def main():
    conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler('start', start),
            MessageHandler(Filters.text & ~Filters.command, handle_message)
        ],
        states={
            CHOOSING: [
                CallbackQueryHandler(button_handler),
                MessageHandler(Filters.text & ~Filters.command, handle_message)
            ],
            TYPING_CATEGORY: [
                CallbackQueryHandler(button_handler),
                MessageHandler(Filters.text & ~Filters.command, handle_message)
            ],
            TYPING_QUESTION: [
                MessageHandler(Filters.text & ~Filters.command, handle_regular_message),
                CallbackQueryHandler(button_handler)
            ],
            TYPING_REPLY: [
                MessageHandler(Filters.text & ~Filters.command, handle_regular_message),
                CallbackQueryHandler(button_handler)
            ]
        },
        fallbacks=[CommandHandler('cancel', cancel)],
    )

    application.add_handler(conv_handler)
    application.add_handler(CallbackQueryHandler(button_handler))

    loop = asyncio.get_event_loop()
    loop.run_until_complete(start_server())
    logger.info("Ğ¡ĞµÑ€Ğ²ĞµÑ€ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½Ğ¾ Ğ½Ğ° Ğ¿Ğ¾Ñ€Ñ‚Ñƒ 8080")
    loop.run_forever()

if __name__ == "__main__":
    main()

# Ğ”Ğ¾Ğ´Ğ°Ğ¹Ñ‚Ğµ Ñ€ĞµÑˆÑ‚Ñƒ Ñ„ÑƒĞ½ĞºÑ†Ñ–Ğ¹ Ğ· Ğ²Ğ°ÑˆĞ¾Ğ³Ğ¾ Ğ¾Ñ€Ğ¸Ğ³Ñ–Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ´Ñƒ Ğ½Ğ¸Ğ¶Ñ‡Ğµ:

def get_admin_menu_keyboard():
    keyboard = [
        ["ğŸ“¥ ĞĞ¾Ğ²Ñ– Ğ¿Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ", "â­ï¸ Ğ’Ğ°Ğ¶Ğ»Ğ¸Ğ²Ñ– Ğ¿Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ"],
        ["âœ… ĞĞ¿Ñ€Ğ°Ñ†ÑŒĞ¾Ğ²Ğ°Ğ½Ñ–", "âŒ Ğ’Ñ–Ğ´Ñ…Ğ¸Ğ»ĞµĞ½Ñ–"],
        ["ğŸ”„ Ğ—Ğ¼Ñ–Ğ½Ğ¸Ñ‚Ğ¸ Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´ÑŒ", "ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°"]
    ]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

def get_questions_list_keyboard(questions: List[dict], page: int = 0, items_per_page: int = 5):
    keyboard = []
    start_idx = page * items_per_page
    end_idx = start_idx + items_per_page
    
    for q in questions[start_idx:end_idx]:
        status_emoji = {'pending': 'â³', 'answered': 'âœ…', 'rejected': 'âŒ'}.get(q['status'], 'â³')
        short_text = q['text'][:30] + '...' if len(q['text']) > 30 else q['text']
        keyboard.append([InlineKeyboardButton(f"{status_emoji} {CATEGORIES[q['category']]}: {short_text}", callback_data=f"view_q_{q['id']}")])
        if q['status'] == 'rejected':
            keyboard.append([InlineKeyboardButton("â†©ï¸ Ğ’Ñ–Ğ´Ğ½Ğ¾Ğ²Ğ¸Ñ‚Ğ¸", callback_data=f"restore_{q['id']}")])
    
    nav_buttons = []
    if page > 0:
        nav_buttons.append(InlineKeyboardButton("â¬…ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data=f"page_{page-1}"))
    if end_idx < len(questions):
        nav_buttons.append(InlineKeyboardButton("â¡ï¸ Ğ’Ğ¿ĞµÑ€ĞµĞ´", callback_data=f"page_{page+1}"))
    if nav_buttons:
        keyboard.append(nav_buttons)
    
    keyboard.append([InlineKeyboardButton("ğŸ”™ Ğ’ Ğ¼ĞµĞ½Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°", callback_data="admin_menu")])
    return InlineKeyboardMarkup(keyboard)

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data.clear()
    await update.message.reply_text("âŒ Ğ”Ñ–Ñ ÑĞºĞ°ÑĞ¾Ğ²Ğ°Ğ½Ğ¾.\nĞĞ±ĞµÑ€Ñ–Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñƒ Ğ´Ñ–Ñ:", reply_markup=get_main_keyboard())
    return CHOOSING

async def show_my_questions(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_questions = [q for q_id, q in db.questions.items() if q.get('user_id') == user_id]
    
    if not user_questions:
        await update.message.reply_text("ğŸ“ Ğ£ Ğ²Ğ°Ñ Ğ¿Ğ¾ĞºĞ¸ Ğ½ĞµĞ¼Ğ°Ñ” Ğ¿Ğ¸Ñ‚Ğ°Ğ½ÑŒ.", reply_markup=get_main_keyboard())
        return CHOOSING
    
    questions_text = "ğŸ“‹ Ğ’Ğ°ÑˆÑ– Ğ¿Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ:\n\n"
    for i, q in enumerate(user_questions, 1):
        status = {'pending': 'â³ ĞÑ‡Ñ–ĞºÑƒÑ”', 'answered': 'âœ… Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´ÑŒ', 'rejected': 'âŒ Ğ’Ñ–Ğ´Ñ…Ğ¸Ğ»ĞµĞ½Ğ¾'}.get(q['status'], 'â³ ĞÑ‡Ñ–ĞºÑƒÑ”')
        questions_text += f"{i}. {CATEGORIES[q['category']]}\nĞŸĞ¸Ñ‚Ğ°Ğ½Ğ½Ñ: {q['text']}\nĞ¡Ñ‚Ğ°Ñ‚ÑƒÑ: {status}\n\n"
    
    await update.message.reply_text(questions_text, reply_markup=get_main_keyboard())
    return CHOOSING

async def show_my_answers(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    answered_questions = [q for q_id, q in db.questions.items() if q.get('user_id') == user_id and q.get('status') == 'answered']
    
    if not answered_questions:
        await update.message.reply_text("ğŸ“ Ğ£ Ğ²Ğ°Ñ Ğ¿Ğ¾ĞºĞ¸ Ğ½ĞµĞ¼Ğ°Ñ” Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´ĞµĞ¹.", reply_markup=get_main_keyboard())
        return CHOOSING
    
    answers_text = "âœ‰ï¸ Ğ’Ğ°ÑˆÑ– Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ñ–:\n\n"
    for i, q in enumerate(answered_questions, 1):
        answers_text += f"{i}. {CATEGORIES[q['category']]}\nĞŸĞ¸Ñ‚Ğ°Ğ½Ğ½Ñ: {q['text']}\nĞ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´ÑŒ: {q.get('answer', '')}\n\n"
    
    await update.message.reply_text(answers_text, reply_markup=get_main_keyboard())
    return CHOOSING

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    text = update.message.text
    is_admin = user_id in ADMIN_IDS

    if update.effective_chat.type == 'private':
        if text == "ğŸ“ Ğ—Ğ°Ğ´Ğ°Ñ‚Ğ¸ Ğ¿Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ":
            await update.message.reply_text("ğŸ“ ĞĞ±ĞµÑ€Ñ–Ñ‚ÑŒ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ñ–Ñ:", reply_markup=get_category_keyboard())
            return TYPING_CATEGORY
        elif text == "ğŸ“‹ ĞœĞ¾Ñ— Ğ¿Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ":
            return await show_my_questions(update, context)
        elif text == "âœ‰ï¸ ĞœĞ¾Ñ— Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ñ–":
            return await show_my_answers(update, context)
        elif text == "â“ Ğ”Ğ¾Ğ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°":
            help_text = (
                "ğŸ“Œ Ğ¯Ğº ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‚Ğ¸ÑÑ:\n"
                "1ï¸âƒ£ ĞĞ°Ñ‚Ğ¸ÑĞ½Ñ–Ñ‚ÑŒ 'ğŸ“ Ğ—Ğ°Ğ´Ğ°Ñ‚Ğ¸ Ğ¿Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ'\n"
                "2ï¸âƒ£ ĞĞ±ĞµÑ€Ñ–Ñ‚ÑŒ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ñ–Ñ\n"
                "3ï¸âƒ£ ĞĞ°Ğ¿Ğ¸ÑˆÑ–Ñ‚ÑŒ Ğ¿Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ\n"
                "Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ñ– Ğ·â€™ÑĞ²Ğ»ÑÑ‚ÑŒÑÑ Ğ² ĞºĞ°Ğ½Ğ°Ğ»Ñ–."
            )
            await update.message.reply_text(help_text)
            return CHOOSING
        elif text == "ğŸ“¢ ĞšĞ°Ğ½Ğ°Ğ» Ğ· Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´ÑĞ¼Ğ¸":
            await update.message.reply_text(
                "ĞŸĞµÑ€ĞµĞ¹Ğ´Ñ–Ñ‚ÑŒ Ñƒ ĞºĞ°Ğ½Ğ°Ğ»:",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("ğŸ“¢ ĞšĞ°Ğ½Ğ°Ğ»", url=f"https://t.me/{CHANNEL_ID.lstrip('@')}")]])
            )
            return CHOOSING
        elif is_admin and text in ["ğŸ“¥ ĞĞ¾Ğ²Ñ– Ğ¿Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ", "â­ï¸ Ğ’Ğ°Ğ¶Ğ»Ğ¸Ğ²Ñ– Ğ¿Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ", "âœ… ĞĞ¿Ñ€Ğ°Ñ†ÑŒĞ¾Ğ²Ğ°Ğ½Ñ–", "âŒ Ğ’Ñ–Ğ´Ñ…Ğ¸Ğ»ĞµĞ½Ñ–", "ğŸ”„ Ğ—Ğ¼Ñ–Ğ½Ğ¸Ñ‚Ğ¸ Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´ÑŒ", "ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°"]:
            return await handle_admin_menu(update, context)
        else:
            keyboard = get_admin_menu_keyboard() if is_admin else get_main_keyboard()
            await update.message.reply_text("ĞĞ±ĞµÑ€Ñ–Ñ‚ÑŒ Ğ¾Ğ¿Ñ†Ñ–Ñ:", reply_markup=keyboard)
            return CHOOSING
    return await handle_regular_message(update, context)

async def handle_regular_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    message_text = update.message.text

    if context.user_data.get('answering') and user_id in ADMIN_IDS:
        question_id = context.user_data['answering']
        question = db.questions[question_id]
        answer_text = message_text
        message_text = f"â“ {CATEGORIES[question['category']]}\n\n{question['text']}\n\nâœ… Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´ÑŒ:\n{answer_text}"
        message = await context.bot.send_message(chat_id=CHANNEL_ID, text=message_text)
        db.update_question(question_id, {
            'status': 'answered',
            'answer': answer_text,
            'answer_time': datetime.now().isoformat(),
            'answer_message_id': message.message_id
        })
        context.user_data.clear()
        await update.message.reply_text("âœ… Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´ÑŒ Ğ¾Ğ¿ÑƒĞ±Ğ»Ñ–ĞºĞ¾Ğ²Ğ°Ğ½Ğ¾", reply_markup=get_admin_menu_keyboard())
        return CHOOSING

    elif context.user_data.get('category') and context.user_data.get('waiting_for_question'):
        category = context.user_data['category']
        question_id = f"q{len(db.questions) + 1}"
        db.add_question(question_id, {
            'id': question_id,
            'category': category,
            'text': message_text,
            'status': 'pending',
            'time': datetime.now().isoformat(),
            'important': False,
            'user_id': user_id
        })
        await handle_admin_question(update, context, question_id)
        context.user_data.clear()
        await update.message.reply_text("âœ… ĞŸĞ¸Ñ‚Ğ°Ğ½Ğ½Ñ Ğ½Ğ°Ğ´Ñ–ÑĞ»Ğ°Ğ½Ğ¾!", reply_markup=get_main_keyboard())
        return CHOOSING

    else:
        await update.message.reply_text("â—ï¸ Ğ’Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒĞ¹Ñ‚Ğµ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸.", reply_markup=get_main_keyboard())
        return CHOOSING

async def handle_admin_question(update: Update, context: ContextTypes.DEFAULT_TYPE, question_id: str):
    question = db.questions[question_id]
    message_text = f"ğŸ“¨ ĞĞ¾Ğ²Ğµ Ğ¿Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ\n\nĞšĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ñ–Ñ: {CATEGORIES[question['category']]}\nĞŸĞ¸Ñ‚Ğ°Ğ½Ğ½Ñ: {question['text']}"
    await context.bot.send_message(chat_id=int(ADMIN_GROUP_ID), text=message_text, reply_markup=get_admin_keyboard(question_id))

async def handle_admin_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    if text == "ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°":
        stats_text = (
            f"ğŸ“ Ğ’ÑÑŒĞ¾Ğ³Ğ¾: {db.stats['total_questions']}\n"
            f"âœ… Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ñ–: {db.stats['answered_questions']}\n"
            f"â³ ĞÑ‡Ñ–ĞºÑƒÑÑ‚ÑŒ: {db.stats['total_questions'] - db.stats['answered_questions']}\n\n"
            "ğŸ“Š ĞšĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ñ–Ñ—:\n"
        )
        for cat_id, cat_name in CATEGORIES.items():
            stats_text += f"{cat_name}: {db.stats['categories'].get(cat_id, 0)}\n"
        await update.message.reply_text(stats_text, reply_markup=get_admin_menu_keyboard())
    elif text == "ğŸ“¥ ĞĞ¾Ğ²Ñ– Ğ¿Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ":
        new_questions = [q for q in db.questions.values() if q['status'] == 'pending']
        if not new_questions:
            await update.message.reply_text("ğŸ“­ ĞĞµĞ¼Ğ°Ñ” Ğ½Ğ¾Ğ²Ğ¸Ñ… Ğ¿Ğ¸Ñ‚Ğ°Ğ½ÑŒ", reply_markup=get_admin_menu_keyboard())
        else:
            context.user_data['current_questions'] = new_questions
            context.user_data['current_page'] = 0
            await update.message.reply_text("ğŸ“¥ ĞĞ¾Ğ²Ñ– Ğ¿Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ:", reply_markup=get_questions_list_keyboard(new_questions))
    return CHOOSING

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user_id = query.from_user.id
    data = query.data
    await query.answer()

    if data == "back_to_main":
        await query.message.edit_text("ĞĞ±ĞµÑ€Ñ–Ñ‚ÑŒ Ğ´Ñ–Ñ:", reply_markup=get_main_keyboard())
        context.user_data.clear()
        return CHOOSING
    elif data.startswith("cat_"):
        category = data.replace("cat_", "")
        context.user_data['category'] = category
        context.user_data['waiting_for_question'] = True
        await query.message.edit_text(f"ğŸ“ {CATEGORIES[category]}\nĞĞ°Ğ¿Ğ¸ÑˆÑ–Ñ‚ÑŒ Ğ¿Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ:")
        return TYPING_QUESTION
    elif data.startswith("answer_"):
        question_id = data.replace("answer_", "")
        context.user_data['answering'] = question_id
        question = db.questions[question_id]
        await query.message.edit_text(f"âœï¸ {CATEGORIES[question['category']]}\n{question['text']}\nĞĞ°Ğ¿Ğ¸ÑˆÑ–Ñ‚ÑŒ Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´ÑŒ:")
        return TYPING_REPLY
    elif data.startswith("reject_"):
        question_id = data.replace("reject_", "")
        db.update_question(question_id, {'status': 'rejected'})
        await query.message.edit_text(f"âŒ ĞŸĞ¸Ñ‚Ğ°Ğ½Ğ½Ñ Ğ²Ñ–Ğ´Ñ…Ğ¸Ğ»ĞµĞ½Ğ¾")
        return CHOOSING
    elif data.startswith("important_"):
        question_id = data.replace("important_", "")
        question = db.questions[question_id]
        is_important = not question.get('important', False)
        db.update_question(question_id, {'important': is_important})
        await query.message.edit_text(f"{'â­ï¸ Ğ’Ğ°Ğ¶Ğ»Ğ¸Ğ²Ğµ' if is_important else 'ğŸ”µ Ğ—Ğ²Ğ¸Ñ‡Ğ°Ğ¹Ğ½Ğµ'}", reply_markup=get_admin_keyboard(question_id))
        return CHOOSING
    elif data.startswith("pin_"):
        question_id = data.replace("pin_", "")
        await context.bot.pin_chat_message(chat_id=int(ADMIN_GROUP_ID), message_id=query.message.message_id)
        await query.answer("ğŸ“Œ Ğ—Ğ°ĞºÑ€Ñ–Ğ¿Ğ»ĞµĞ½Ğ¾!")
        return CHOOSING
    return CHOOSING
```

#### **requirements.txt**
Ğ¡Ñ‚Ğ²Ğ¾Ñ€Ñ–Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ» Ñ–Ğ· Ğ·Ğ°Ğ»ĞµĞ¶Ğ½Ğ¾ÑÑ‚ÑĞ¼Ğ¸:

```
python-telegram-bot==20.8
python-dotenv==1.0.1
aiohttp==3.9.5
```

#### **.env**
Ğ¡Ñ‚Ğ²Ğ¾Ñ€Ñ–Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ» `.env` Ñ–Ğ· Ğ²Ğ°ÑˆĞ¸Ğ¼Ğ¸ Ğ´Ğ°Ğ½Ğ¸Ğ¼Ğ¸:

```
TELEGRAM_TOKEN=7540984242:AAHwnXjpUHjmV4bjCeKgTq7YR0_9fVC_OHs
CHANNEL_ID=@christ_qa
ADMIN_GROUP_ID=-1002576988593
ADMIN_IDS=404389668
```

#### **Dockerfile**
Ğ¡Ñ‚Ğ²Ğ¾Ñ€Ñ–Ñ‚ÑŒ `Dockerfile` Ğ´Ğ»Ñ ĞºĞ¾Ğ½Ñ‚ĞµĞ¹Ğ½ĞµÑ€Ğ¸Ğ·Ğ°Ñ†Ñ–Ñ—:

```
FROM python:3.9-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
EXPOSE 8080
CMD ["python", "bot.py"]
```

#### **.dockerignore**
Ğ¡Ñ‚Ğ²Ğ¾Ñ€Ñ–Ñ‚ÑŒ `.dockerignore`:

```
__pycache__
*.pyc
*.pyo
.env
```

#### **db.json**
Ğ¡Ñ‚Ğ²Ğ¾Ñ€Ñ–Ñ‚ÑŒ Ğ¿Ğ¾Ñ‡Ğ°Ñ‚ĞºĞ¾Ğ²Ğ¸Ğ¹ Ñ„Ğ°Ğ¹Ğ» Ğ±Ğ°Ğ·Ğ¸ Ğ´Ğ°Ğ½Ğ¸Ñ…:

```json
{
  "questions": {},
  "stats": {
    "total_questions": 0,
    "answered_questions": 0,
    "categories": {
      "general": 0,
      "spiritual": 0,
      "personal": 0,
      "urgent": 0
    }
  }
}
```

---

## ĞšÑ€Ğ¾Ğº 2: ĞĞ°Ğ»Ğ°ÑˆÑ‚ÑƒĞ²Ğ°Ğ½Ğ½Ñ Google Cloud

### 2.1. ĞĞ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ†Ñ–Ñ

Ğ£Ğ²Ñ–Ğ¹Ğ´Ñ–Ñ‚ÑŒ Ñƒ Google Cloud:

```bash
gcloud auth login
```

### 2.2. Ğ¡Ñ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ Ğ¿Ñ€Ğ¾Ñ”ĞºÑ‚Ñƒ

Ğ¡Ñ‚Ğ²Ğ¾Ñ€Ñ–Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ñ”ĞºÑ‚ (Ğ·Ğ°Ğ¼Ñ–Ğ½Ñ–Ñ‚ÑŒ `telegram-qa-bot-123` Ğ½Ğ° ÑƒĞ½Ñ–ĞºĞ°Ğ»ÑŒĞ½Ğ¸Ğ¹ ID):

```bash
gcloud projects create telegram-qa-bot-123 --set-as-default
gcloud config set project telegram-qa-bot-123
```

### 2.3. Ğ£Ğ²Ñ–Ğ¼ĞºĞ½ĞµĞ½Ğ½Ñ API

Ğ£Ğ²Ñ–Ğ¼ĞºĞ½Ñ–Ñ‚ÑŒ API:

```bash
gcloud services enable run.googleapis.com artifactregistry.googleapis.com
```

### 2.4. ĞĞ°Ğ»Ğ°ÑˆÑ‚ÑƒĞ²Ğ°Ğ½Ğ½Ñ Artifact Registry

Ğ¡Ñ‚Ğ²Ğ¾Ñ€Ñ–Ñ‚ÑŒ Ñ€ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ñ€Ñ–Ğ¹ Ğ´Ğ»Ñ Docker-Ğ¾Ğ±Ñ€Ğ°Ğ·Ñ–Ğ² (Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒĞ¹Ñ‚Ğµ Ğ²Ğ°Ñˆ Ñ€ĞµĞ³Ñ–Ğ¾Ğ½, Ğ½Ğ°Ğ¿Ñ€Ğ¸ĞºĞ»Ğ°Ğ´, `europe-west1`):

```bash
gcloud artifacts repositories create qa-bot-repo --repository-format=docker --location=europe-west1
```

---

## ĞšÑ€Ğ¾Ğº 3: Ğ¡Ğ±Ğ¾Ñ€ĞºĞ° Ñ‚Ğ° Ñ€Ğ¾Ğ·Ğ³Ğ¾Ñ€Ñ‚Ğ°Ğ½Ğ½Ñ

### 3.1. Ğ¡Ğ±Ğ¾Ñ€ĞºĞ° Docker-Ğ¾Ğ±Ñ€Ğ°Ğ·Ñƒ

ĞŸĞ¾Ğ±ÑƒĞ´ÑƒĞ¹Ñ‚Ğµ Ğ¾Ğ±Ñ€Ğ°Ğ·:

```bash
docker build -t qa-bot .
```

### 3.2. Ğ¢ĞµĞ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ñ‚Ğ° Ğ·Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ĞµĞ½Ğ½Ñ

Ğ¢ĞµĞ³Ğ½Ñ–Ñ‚ÑŒ Ñ– Ğ·Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶Ñ‚Ğµ Ğ¾Ğ±Ñ€Ğ°Ğ· (Ğ·Ğ°Ğ¼Ñ–Ğ½Ñ–Ñ‚ÑŒ `europe-west1` Ñ– `telegram-qa-bot-123`):

```bash
docker tag qa-bot europe-west1-docker.pkg.dev/telegram-qa-bot-123/qa-bot-repo/qa-bot
docker push europe-west1-docker.pkg.dev/telegram-qa-bot-123/qa-bot-repo/qa-bot
```

### 3.3. Ğ Ğ¾Ğ·Ğ³Ğ¾Ñ€Ñ‚Ğ°Ğ½Ğ½Ñ Ğ½Ğ° Google Cloud Run

Ğ Ğ¾Ğ·Ğ³Ğ¾Ñ€Ğ½Ñ–Ñ‚ÑŒ ÑĞµÑ€Ğ²Ñ–Ñ:

```bash
gcloud run deploy telegram-qa-bot \
  --image europe-west1-docker.pkg.dev/telegram-qa-bot-123/qa-bot-repo/qa-bot \
  --platform managed \
  --region europe-west1 \
  --allow-unauthenticated \
  --port 8080 \
  --set-env-vars "TELEGRAM_TOKEN=7540984242:AAHwnXjpUHjmV4bjCeKgTq7YR0_9fVC_OHs,CHANNEL_ID=@christ_qa,ADMIN_GROUP_ID=-1002576988593,ADMIN_IDS=404389668"
```

---

## ĞšÑ€Ğ¾Ğº 4: ĞĞ°Ğ»Ğ°ÑˆÑ‚ÑƒĞ²Ğ°Ğ½Ğ½Ñ Webhook

### 4.1. ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ URL

ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ¹Ñ‚Ğµ URL ÑĞµÑ€Ğ²Ñ–ÑÑƒ:

```bash
SERVICE_URL=$(gcloud run services describe telegram-qa-bot --platform managed --region europe-west1 --format 'value(status.url)')
echo $SERVICE_URL
```

### 4.2. Ğ’ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ Webhook

ĞĞ°Ğ»Ğ°ÑˆÑ‚ÑƒĞ¹Ñ‚Ğµ Webhook:

```bash
curl -F "url=${SERVICE_URL}/webhook" "https://api.telegram.org/bot7540984242:AAHwnXjpUHjmV4bjCeKgTq7YR0_9fVC_OHs/setWebhook"
```

ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€Ñ‚Ğµ ÑÑ‚Ğ°Ñ‚ÑƒÑ:

```bash
curl "https://api.telegram.org/bot7540984242:AAHwnXjpUHjmV4bjCeKgTq7YR0_9fVC_OHs/getWebhookInfo"
```

---

## ĞšÑ€Ğ¾Ğº 5: Ğ¢ĞµÑÑ‚ÑƒĞ²Ğ°Ğ½Ğ½Ñ

1. ĞĞ°Ğ¿Ğ¸ÑˆÑ–Ñ‚ÑŒ `/start` Ğ±Ğ¾Ñ‚Ñƒ.
2. ĞĞ°Ñ‚Ğ¸ÑĞ½Ñ–Ñ‚ÑŒ "ğŸ“ Ğ—Ğ°Ğ´Ğ°Ñ‚Ğ¸ Ğ¿Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ", Ğ¾Ğ±ĞµÑ€Ñ–Ñ‚ÑŒ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ñ–Ñ, Ğ²Ğ²ĞµĞ´Ñ–Ñ‚ÑŒ Ğ¿Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ.
3. ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€Ñ‚Ğµ, Ñ‡Ğ¸ Ğ·â€™ÑĞ²Ğ¸Ğ»Ğ¾ÑÑŒ Ğ¿Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ Ğ² Ğ³Ñ€ÑƒĞ¿Ñ– `-1002576988593`.
4. Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ¹Ñ‚Ğµ ÑĞº Ğ°Ğ´Ğ¼Ñ–Ğ½Ñ–ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ñ– Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€Ñ‚Ğµ Ğ¿ÑƒĞ±Ğ»Ñ–ĞºĞ°Ñ†Ñ–Ñ Ğ² `@christ_qa`.

---

## Ğ£ÑÑƒĞ½ĞµĞ½Ğ½Ñ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼

- **Ğ›Ğ¾Ğ³Ğ¸**:
  ```bash
  gcloud logging read "resource.type=cloud_run_revision" --project telegram-qa-bot-123
  ```
- **Webhook**:
  ```bash
  curl "https://api.telegram.org/bot7540984242:AAHwnXjpUHjmV4bjCeKgTq7YR0_9fVC_OHs/getWebhookInfo"
  ```

---

## Ğ’Ğ¸ÑĞ½Ğ¾Ğ²Ğ¾Ğº

Ğ’Ñ–Ñ‚Ğ°Ñ! Ğ’Ğ¸ ÑÑ‚Ğ²Ğ¾Ñ€Ğ¸Ğ»Ğ¸ Ñ‚Ğ° Ñ€Ğ¾Ğ·Ğ³Ğ¾Ñ€Ğ½ÑƒĞ»Ğ¸ Telegram-Ğ±Ğ¾Ñ‚Ğ° Ğ½Ğ° Google Cloud Run. Ğ’Ñ–Ğ½ Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ¸Ğ¹ Ğ¿Ñ€Ğ¸Ğ¹Ğ¼Ğ°Ñ‚Ğ¸ Ğ°Ğ½Ğ¾Ğ½Ñ–Ğ¼Ğ½Ñ– Ğ¿Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ, Ğ¿ĞµÑ€ĞµĞ´Ğ°Ğ²Ğ°Ñ‚Ğ¸ Ñ—Ñ… Ğ°Ğ´Ğ¼Ñ–Ğ½Ñ–ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°Ğ¼ Ñ– Ğ¿ÑƒĞ±Ğ»Ñ–ĞºÑƒĞ²Ğ°Ñ‚Ğ¸ Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ñ– Ğ² `@christ_qa`. Ğ£Ğ´Ğ°Ñ‡Ñ–! ğŸš€